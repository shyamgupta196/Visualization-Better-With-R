---
title: "Visualize Better with R"
author:
  - name: "Shyam Gupta"
    email: shyam.gupta@gesis.org
    orcid: "https://orcid.org/0009-0003-4639-5618"
    affiliation: "GESIS Leibniz Institute for the Social Sciences"
date: "2025-04-10"
format:
  html:
    toc: true       # Generate table of contents automatically
    toc-depth: 4    # Include up to 4 header levels in TOC
    code-fold: false # Allow folding of code chunks in HTML output
    theme: cosmo    # Use Bootswatch Cosmo theme for a clean look
execute:
  eval: false      # Do not execute code by default
  warning: false   # Suppress warnings in output
  message: false   # Suppress messages in output
  echo: true       # Show code in output
---

[![MethodsHub❤️ Guidelines](https://img.shields.io/badge/MethodsHub_Tutorial-GuidelinesV3-lightblue)](https://github.com/GESIS-Methods-Hub/guidelines-for-tutorials) ![](https://img.shields.io/badge/License-MIT-blue) ![](https://img.shields.io/badge/PR's-Welcome-lightgreen)

## Learning Objective
I was working on a social science research project—trying to decode the relationship between people’s well-being and their social interactions. After spending hours collecting survey responses, I realized that raw numbers alone weren’t telling the entire story.

> “I needed a better way to visualize my data to spot trends, patterns, and outliers.”  
> That is when my journey with data visualization in **R** began.

By completing this tutorial, you will:

1. Understand the strengths and limitations of each visualization type.
2. Be able to implement and customize these visualizations in `ggplot2` and related packages.
3. Interpret results in the context of social science data exploration.
4. Apply best practices to ensure clarity, accessibility, and reproducibility of your plots.

In this tutorial, I’ll walk you through the plots and visual techniques. I’ll share each plot, explaining *why* you might want to use them, *what* they reveal, and *how* to make them.

By the end of this tutorial, you’ll have a handy arsenal of 9 powerful visualization techniques perfect for social science data exploration. Let’s get started!

## Target Audience

This tutorial is designed for:

- **Social Science Researchers & Graduate Students:** Those analyzing survey or observational data who need clear, reproducible visualizations to support hypotheses and publications.
- **Data Analysts & Statisticians:** Professionals exploring complex datasets in R who want to expand their toolbox with advanced plotting techniques.
- **Academic Instructors & Educators:** Teachers seeking structured examples to demonstrate best practices in data visualization to social science students.
- **Interdisciplinary Teams & Policy Analysts:** Practitioners who require accessible, publication-quality figures to communicate insights to stakeholders and decision-makers.

## Computational Environment Setup

Ensure you have **R (version 3.6.0 or higher)** installed on your system.  
You can download it from: https://cran.r-project.org/.

Install the required R packages by running:

```r
# Core data wrangling & plotting
install.packages("dplyr")
install.packages("hrbrthemes")
install.packages("tidyr")
install.packages("ggplot2")

# Specialized geoms
install.packages("ggbeeswarm")
install.packages("forcats")

# Time series utilities
install.packages("zoo")

# Correlation plotting
install.packages("corrplot")

# Mapping
install.packages("maps")
install.packages("viridis")     # for color scales on maps

# (Optional) Color‐blind–friendly palettes
install.packages("viridisLite")


## Estimated Duration

- **Reading & Setup:** 5 minutes
- **Code Walkthrough:** 20–30 minutes
- **Hands-on Practice:** 10–15 minutes

Total: **35–50 minutes**

## Input Data

```
# 1. Generate synthetic dataset
set.seed(42)
df <- data.frame(
  radius_mean    = runif(100, min = 12, max = 16),
  texture_mean   = runif(100, min = 15, max = 25),
  perimeter_mean = runif(100, min = 70, max = 110),
  area_mean      = runif(100, min = 350, max = 750),
  concavity_mean = runif(100, min = 0.1, max = 0.5),
  symmetry_mean  = runif(100, min = 0.15, max = 0.25),
  diagnosis      = sample(c("Group A", "Group B"), 100, replace = TRUE)
)

# 2. Reshape data from wide to long format
#    - pivot_longer(): collapse multiple feature columns into key-value pairs


df_long <- df %>%
  pivot_longer(
    cols = radius_mean:symmetry_mean,
    names_to = "feature",
    values_to = "value"
  )
```



# 1. Swarm Plots over Scatter Plots

## 1.1 Context and Motivation
When comparing numerical values across categories (e.g., satisfaction scores by age group), simple scatter plots may suffer from overplotting: points overlap and hide density information. Swarm plots (bee swarms) solve this by adjusting point positions to minimize overlap, making every observation visible.

## 1.2 Step-by-Step Code

```{r swarm-setup, message=FALSE, warning=FALSE}
# 1. Load necessary libraries
library(dplyr)       # Data manipulation
library(tidyr)       # Data reshaping
library(ggplot2)     # Core plotting package
library(ggbeeswarm)  # For geom_beeswarm()
```

```{r swarm-plot, fig.width=7, fig.height=5}
# 2. Create a swarm plot
#    - aes(x=feature, y=value): map feature names on x-axis and values on y-axis
#    - color by diagnosis group

swarm_plot <- ggplot(df_long, aes(x = feature, y = value, color = diagnosis)) +
  geom_beeswarm(alpha = 0.8, size = 2) + # geom_beeswarm arranges points to avoid overlap
  theme_minimal(base_size = 14) +        # clean background
  labs(
    title = "Distribution of Mean Features by Diagnosis Group",
    subtitle = "Swarm plot reveals every individual observation without overlap",
    x = "Feature",
    y = "Value",
    color = "Diagnosis Group"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), # rotate x-axis labels
    legend.position = "top"
  )

print(swarm_plot)
```

## 1.3 Explanation & Interpretation

- **geom_beeswarm():** Positions points in a compact, non-overlapping arrangement. Useful for moderate sample sizes (<200).  
- **Transparency (`alpha`):** Helps reveal point density when slight overlap occurs.  

**Interpretation:** In the resulting plot, clusters of points indicate where many observations fall. Differences in the vertical spread between Group A and Group B highlight variability in that feature.

## 1.4 Customization Tips

- **Point shape & size:** use `shape=` and `size=` inside `geom_beeswarm()`.  
- **Color palettes:** integrate `scale_color_brewer(palette = "Set1")` or `scale_color_viridis_d()` for colorblind-friendly palettes.  
- **Grouping multiple categories:** for more than two groups, ensure contrast in color or shape.

## 1.5 Common Pitfalls

- **Large datasets:** for >500 points, swarm plots can become cluttered; consider violin or box plots instead.  
- **Uneven group sizes:** extremely small groups may appear as lone points; annotate directly if needed.


# 2. Density Plots

## 2.1 Context and Motivation
Histograms show frequency distribution through bars, but bin choice can obscure distribution shape. Density plots provide a smooth estimate of the distribution, enabling direct comparison of multiple groups.

## 2.2 Step-by-Step Code

```{r density-setup, message=FALSE}
library(ggplot2)
# assuming `df` from section 1 is available
```

```{r density-plot, fig.width=7, fig.height=5}
# Create density plot

density_plot <- ggplot(df, aes(x = area_mean, fill = diagnosis)) +
  geom_density(alpha = 0.5, adjust = 1.2) + # adjust smoothness parameter
  theme_minimal(base_size = 14) +
  labs(
    title = "Density Plot of Area Mean by Diagnosis Group",
    subtitle = "Smoothed distribution of 'area_mean' across groups",
    x = "Area Mean",
    y = "Density",
    fill = "Group"
  )

print(density_plot)
```

## 2.3 Explanation & Interpretation

- **adjust:** controls bandwidth of density estimation (higher = smoother).  
- **alpha:** semi-transparency allows overlapping fills to be distinguishable.  

**Interpretation:** Overlap between curves indicates similar distributions. Divergence reveals differences in modality or skewness.

## 2.4 Customization Tips

- To overlay median lines: add `geom_vline(data = summary_df, aes(xintercept = median), linetype = "dashed")`.  
- Compare more than two groups: use faceting (`facet_wrap(~diagnosis)`).  
- Show rug plots: `geom_rug(alpha = 0.3)` adds tick marks for individual observations.

## 2.5 Common Pitfalls

- Misleading smoothing: overly small `adjust` can produce spurious bumps; overly large can mask real structure.  
- Overlapping groups of very different sample sizes: transparency alone may not suffice—consider facetting or scaling.


# 3. Box Plots with Jitter

## 3.1 Context and Motivation
Boxplots summarize distribution via quartiles, but hide individual points. Adding jittered points atop the boxplot provides both summary and raw data.

## 3.2 Step-by-Step Code

```{r boxjitter-setup, message=FALSE}
library(ggplot2)
# Simulate data with varied group sizes
set.seed(123)
data_box <- data.frame(
  region = rep(c("North","South","East","West"), times = c(150, 150, 30, 70)),
  score  = c(rnorm(150, 50, 10), rnorm(150, 55, 8), rnorm(30, 65, 12), rnorm(70, 52, 9))
)
```

```{r boxjitter-plot, fig.width=7, fig.height=5}
# Create boxplot + jitter
box_jitter <- ggplot(data_box, aes(x = region, y = score, fill = region)) +
  geom_boxplot(width = 0.6, outlier.shape = NA) +  # remove default outliers
  geom_jitter(width = 0.2, size = 1, alpha = 0.6, color = "black") +
  theme_minimal(base_size = 14) +
  labs(
    title = "Regional Score Distributions with Box Plot + Jitter",
    subtitle = "Combining summary statistics and individual data points",
    x = "Region",
    y = "Score"
  ) +
  theme(legend.position = "none")

print(box_jitter)
```

## 3.3 Explanation & Interpretation

- **geom_boxplot(width, outlier.shape):** Adjust box width and hide default outliers (since jitter layer shows them).  
- **geom_jitter(width):** Spread points horizontally to prevent overlap—`width` controls spread.  

**Interpretation:** The thickness of the box reflects interquartile range, whiskers show variability, and jitter points reveal clusters or potential subgroups.

## 3.4 Customization Tips

- Use `scale_fill_viridis_d()` for accessible color maps.  
- Add notched boxplots (`geom_boxplot(notch = TRUE)`) to compare medians with confidence intervals.

## 3.5 Common Pitfalls

- Excessive jitter on large samples: reduce `alpha` or sample points for clarity.  
- Misalignment: ensure point layer is added after boxplot layer.


# 4. Violin Plots

## 4.1 Context and Motivation
Violin plots combine density estimation with a mirrored shape around the axis, showing full distribution shape and optional internal boxplot.

## 4.2 Step-by-Step Code

```{r violin-setup, message=FALSE}
library(ggplot2)
library(dplyr)
library(forcats)

# Load example dataset
url <- "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/10_OneNumSevCatSubgroupsSevObs.csv"
data_violin <- read.csv(url) %>%
  mutate(tip_pct = round(tip/total_bill * 100, 1))
```

```{r violin-plot, fig.width=7, fig.height=5}
# Create violin plot
violin_plot <- ggplot(data_violin, aes(x = fct_reorder(day, tip_pct), y = tip_pct, fill = sex)) +
  geom_violin(position = position_dodge(width = 0.9), alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.1, position = position_dodge(width = 0.9), outlier.shape = NA, alpha = 0.5) +
  coord_cartesian(ylim = c(0, 40)) +
  labs(
    title = "Tip Percentage by Day of Week and Gender",
    subtitle = "Violin plots show kernel density; boxplots show quartiles",
    x = "Day of Week",
    y = "Tip (% of Total Bill)",
    fill = "Gender"
  ) +
  theme_minimal(base_size = 14)

print(violin_plot)
```

## 4.3 Explanation & Interpretation

- **trim = FALSE:** Display full tail of density beyond data range.  
- **geom_boxplot():** Adds quartile summary inside violins.  

**Interpretation:** Wider sections of the violin indicate where tips concentrate. Differences between days/genders highlight behavioral patterns.

## 4.4 Customization Tips

- Adjust bandwidth with `geom_violin(..., adjust = 1.5)`.  
- Flip coordinates (`coord_flip()`) for horizontal violins if labels overlap.

## 4.5 Common Pitfalls

- Very small sample sizes: density estimation may be misleading—consider using jitter only.


# 5. Bar + Line Combo Plot

## 5.1 Context and Motivation
Combining bars (absolute values) with a line (trend) highlights both period-specific counts and overall trajectory in time-series data.

## 5.2 Step-by-Step Code
Loading the air passengers dataset.
```{r barline-setup, message=FALSE}
library(ggplot2)
library(zoo)

data("AirPassengers")
df_air <- data.frame(
  Month = as.Date(as.yearmon(time(AirPassengers))),
  Passengers = as.numeric(AirPassengers)
)
```
Now we plot the Bar + Line Combo Plot.
```{r barline-plot, fig.width=7, fig.height=5}
# Create bar + line chart
ggplot(df_air, aes(x = Month)) +
  geom_col(aes(y = Passengers), width = 25, fill = "steelblue", alpha = 0.7) +
  geom_line(aes(y = Passengers), size = 1.2, color = "darkred") +
  labs(
    title = "Monthly International Airline Passengers (1949–1960)",
    subtitle = "Bar = monthly count; Line = overall trend",
    x = "Month",
    y = "Number of Passengers"
  ) +
  scale_x_date(date_labels = "%Y-%m", date_breaks = "1 year") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## 5.3 Explanation & Interpretation

- **geom_col():** Creates bars using data values directly.  
- **geom_line():** Plots a continuous trend line across points.  
- **scale_x_date():** Customizes date axis formatting.

**Interpretation:** Seasonal peaks in summer months emerge clearly via bars, while the red trend line contextualizes year-over-year growth.

## 5.4 Customization Tips

- Add moving average: compute a rolling mean (e.g., `df_air$MA <- rollmean(df_air$Passengers, 12, fill = NA)`) and overlay with `geom_line(aes(y = MA), linetype = "dashed")`.

## 5.5 Common Pitfalls

- Date axis overcrowding: adjust `date_breaks` or rotate labels.  
- Inconsistent widths: ensure `width` aligns with date units (days).


# 6. Correlation Heatmap

## 6.1 Context and Motivation
When exploring relationships among many numerical variables, a correlation matrix is informative but hard to parse. A heatmap visually encodes correlation strength and sign.

## 6.2 Step-by-Step Code

```{r corr-setup, message=FALSE}
library(corrplot)

# Use `df` from section 1: numeric columns only
num_cols <- df %>% select(radius_mean, texture_mean, perimeter_mean, area_mean, concavity_mean, symmetry_mean)
corr_matrix <- cor(num_cols)
```

```{r corr-plot, fig.width=6, fig.height=6}
corrplot(
  corr_matrix,
  method = "shade",       # use shaded squares
  type = "upper",         # show only upper triangle
  tl.col = "black",       # variable names in black
  addCoef.col = "white",  # add correlation coefficients
  number.cex = 0.7,         # size of coefficients
  tl.srt = 45,              # rotate labels
  title = "Correlation Heatmap of Synthetic Features",
  mar = c(0, 0, 2, 0)        # margin for title
)
```

## 6.3 Explanation & Interpretation

- **method:** defines tile style (`shade`, `color`, `circle`).  
- **type = 'upper':** hides redundant lower triangle.  
- **addCoef.col:** overlays numeric r-values.

**Interpretation:** High positive correlations (e.g., `perimeter_mean` vs. `radius_mean`) appear as darker tiles; near-zero appear as lighter.

## 6.4 Customization Tips

- Use `corrplot.mixed()` to combine circle and number views.  
- Cluster variables with `hc.order = TRUE, order = "hclust"` for dendrogram ordering.

## 6.5 Common Pitfalls

- Correlation does not imply causation: always inspect scatter plots for nonlinear patterns.  
- Including non-numeric data: ensure you select only numeric columns.


# 7. Scatter Plot with Regression Line

## 7.1 Context and Motivation
Scatter plots reveal relationships between two continuous variables. Overlaying a fitted regression line helps assess linear association visually.

## 7.2 Step-by-Step Code

```{r scatter-setup, message=FALSE}
# Reuse `df` from section 1
ggplot2::theme_set(theme_minimal(base_size = 14))
```

```{r scatter-plot, fig.width=7, fig.height=5}
scatter_reg <- ggplot(df, aes(x = radius_mean, y = area_mean, color = diagnosis)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, linetype = "dashed") +
  labs(
    title = "Scatter Plot with Linear Regression Line",
    subtitle = "Relationship between radius_mean and area_mean by group",
    x = "Radius Mean",
    y = "Area Mean",
    color = "Diagnosis"
  )

print(scatter_reg)
```

## 7.3 Explanation & Interpretation

- **geom_smooth(method = 'lm', se = TRUE):** adds linear model fit with shaded confidence band.  

**Interpretation:** The slope of the dashed line indicates the strength and direction of the linear relationship. Overlapping confidence bands suggest similar slopes across groups or pooled data.

## 7.4 Customization Tips

- To fit separate models per group: include `aes(group = diagnosis)` inside `geom_smooth()`.  
- For nonlinear trends: use `method = 'loess'`.

## 7.5 Common Pitfalls

- Overfitting with LOESS on large samples—consider limiting points or bandwith.  
- Outliers can disproportionately influence linear fit.


# 8. Stacked Bar Charts

## 8.1 Context and Motivation
Stacked bar charts show total counts per category and the composition of subgroups within each bar—ideal for categorical breakdowns.

## 8.2 Step-by-Step Code

```{r stacked-setup, message=FALSE}
set.seed(123)
df_stack <- data.frame(
  Region = sample(c("North", "South", "East", "West"), 200, replace = TRUE),
  Preference = sample(c("Support", "Oppose", "Neutral"), 200, replace = TRUE)
)
```

```{r stacked-plot, fig.width=7, fig.height=5}
stacked_bar <- ggplot(df_stack, aes(x = Region, fill = Preference)) +
  geom_bar(position = "stack") +
  labs(
    title = "Stacked Bar Chart: Preference by Region",
    subtitle = "Shows both total counts and subgroup composition",
    x = "Region",
    y = "Count",
    fill = "Preference"
  ) +
  theme_minimal(base_size = 14)

print(stacked_bar)
```

## 8.3 Explanation & Interpretation

- **position = 'stack':** default stacking of bars.  

**Interpretation:** The height of each bar indicates total respondents; colored segments reveal proportions of each preference.

## 8.4 Customization Tips

- For relative proportions: use `position = "fill"` to normalize bar heights to 1 (100%).  
- Add labels inside segments with `geom_text(position = position_stack(vjust = 0.5), size = 3)`.

## 8.5 Common Pitfalls

- Too many categories: slices become too thin to interpret; consider faceting instead.  
- Unordered factors: set explicit factor levels for logical ordering.


# 9. Geographical Maps: Choropleth & Point Map

## 9.1 Context and Motivation
Spatial visualizations reveal geographic patterns. Choropleth maps color regions by aggregated values; point maps overlay events or counts at coordinates.

## 9.2 Step-by-Step Code for US Choropleth

```{r map-setup, message=FALSE}
library(ggplot2)
library(maps)
library(dplyr)

# Load map data for US states
states_map <- map_data("state")

# Create synthetic social index data per state
state_data <- data.frame(
  region = tolower(state.name),
  social_index = runif(length(state.name), min = 0, max = 100)
)

# Merge map coordinates with social index
us_data <- left_join(states_map, state_data, by = "region")
```

```{r choropleth-plot, fig.width=7, fig.height=5}
choropleth <- ggplot(us_data, aes(x = long, y = lat, group = group, fill = social_index)) +
  geom_polygon(color = "white") +
  coord_fixed(1.3) +
  scale_fill_viridis_c(option = "plasma") +
  labs(
    title = "Choropleth: US Social Index by State",
    subtitle = "Synthetic data demonstrating thematic mapping",
    fill = "Social Index"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  )

print(choropleth)
```

## 9.3 Explanation & Interpretation

- **coord_fixed(1.3):** ensures correct aspect ratio for maps.  
- **scale_fill_viridis_c():** continuous palette that is perceptually uniform.

**Interpretation:** Darker states have higher social index values in this synthetic example; look for regional clusters (e.g., coastal vs. inland patterns).

## 9.4 Step-by-Step Code for World Point Map

```{r pointmap-plot, fig.width=7, fig.height=5}
# Load world map data
world_map <- map_data("world")

# Create synthetic event data for cities
set.seed(456)
cities <- data.frame(
  city = paste("City", 1:30),
  long = runif(30, -180, 180),
  lat = runif(30, -90, 90),
  event_count = sample(1:100, 30, replace = TRUE)
)

point_map <- ggplot() +
  geom_polygon(
    data = world_map,
    aes(x = long, y = lat, group = group),
    fill = "gray90",
    color = "white"
  ) +
  geom_point(
    data = cities,
    aes(x = long, y = lat, size = event_count),
    alpha = 0.7
  ) +
  coord_fixed(1.3) +
  labs(
    title = "Global Points: Synthetic Social Event Counts",
    subtitle = "Size of point corresponds to event frequency",
    size = "Event Count"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  )

print(point_map)
```

## 9.5 Customization Tips

- Use `coord_quickmap()` for faster rendering on large world datasets.  
- Cluster overlapping points with `geom_jitter()` on lat/long or use packages like `sf` + `ggspatial`.

## 9.6 Common Pitfalls

- Ignoring map projections: for publication, consider appropriate projections with `coord_map()` or `sf`.
- Overplotting in points map: adjust transparency or bin with heatmaps.


# Conclusion

Throughout this tutorial, we've covered:

1. **Swarm Plots:** Reveal individual observations clearly.
2. **Density Plots:** Smooth distributions for group comparison.
3. **Box + Jitter:** Combine summary statistics and raw data.
4. **Violin Plots:** Show full density shapes with internal summaries.
5. **Bar + Line Combo:** Dual view of counts and trends.
6. **Correlation Heatmap:** Visual overview of variable associations.
7. **Scatter + Regression:** Assess linear relationships with confidence bands.
8. **Stacked Bar Charts:** Display totals and compositions of categories.
9. **Geographic Maps:** Thematic and point-based spatial visualizations.

Use these techniques as a foundation. Customize further with color palettes, themes, annotations, and interactivity (e.g., with `plotly` or `shiny`). Share reproducible code, include captions explaining insights, and follow accessibility guidelines to make your research inclusive.

---

## References

- **R for Data Science** (Wickham & Grolemund): Comprehensive guide to data manipulation and visualization in R.  
- **Data to Viz**: https://www.data-to-viz.com/ – A decision tree for selecting appropriate chart types.  
- **ggbeeswarm**: https://cran.r-project.org/package=ggbeeswarm  
- **corrplot**: https://cran.r-project.org/package=corrplot  
- **AirPassengers** dataset documentation: https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/AirPassengers.html

## Contact

Questions? Reach out at shyam.gupta@gesis.org
