)
axs[1, 0].set_title("Anxiety vs Insomnia")
# Bottom-right: Anxiety vs Depression
sns.kdeplot(
data=df, x='Anxiety', y='Depression',
fill=True, levels=10, ax=axs[1, 1], cmap="viridis"
)
axs[1, 1].set_title("Anxiety vs Depression")
plt.tight_layout()
plt.show()
# --------------------------------------------------
# 1. Install/load the required packages
# --------------------------------------------------
# install.packages("dplyr")
# install.packages("tidyr")
# install.packages("ggplot2")
# install.packages("ggbeeswarm")
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggbeeswarm)
# --------------------------------------------------
# 2. Create a synthetic dataset
#    (Replace this part with your actual data)
# --------------------------------------------------
# Set a seed for reproducibility
set.seed(42)
# Create a synthetic dataset using uniform distributions
df <- data.frame(
radius_mean    = runif(100, min = 12, max = 16),      # e.g., values between 12 and 16
texture_mean   = runif(100, min = 15, max = 25),      # values between 15 and 25
perimeter_mean = runif(100, min = 70, max = 110),     # values between 70 and 110
area_mean      = runif(100, min = 350, max = 750),    # values between 350 and 750
concavity_mean = runif(100, min = 0.1, max = 0.5),      # values between 0.1 and 0.5
symmetry_mean  = runif(100, min = 0.15, max = 0.25),    # values between 0.15 and 0.25
diagnosis      = sample(c("M", "B"), 100, replace = TRUE)
)
# --------------------------------------------------
# 3. (Optional) Scale or transform your numeric data
#    so all features are on comparable scales
# --------------------------------------------------
# Using the synthetic dataset from Version 1
df_scaled <- df  # Make a copy of the original dataset
# Define which columns to scale (all numeric features except 'diagnosis')
cols_to_scale <- c("radius_mean", "texture_mean", "perimeter_mean",
"area_mean", "concavity_mean", "symmetry_mean")
# Standardize the numeric columns
df_scaled[cols_to_scale] <- scale(df_scaled[cols_to_scale])
# Preview the standardized dataset
head(df_scaled)
# # Then pivot the scaled columns (if you wanted to compare scaled features).
# # For simplicity here, we'll just pivot the unscaled data.
# --------------------------------------------------
# 4. Reshape your data from "wide" to "long" format
# --------------------------------------------------
# We gather all numeric feature columns (except the 'diagnosis') into
# key-value pairs for feature names and values.
df_long <- df %>%
pivot_longer(
cols = c(radius_mean, texture_mean, perimeter_mean, area_mean,
concavity_mean, symmetry_mean),
names_to = "feature",
values_to = "value"
)
# --------------------------------------------------
# 5. Create the swarm (bee swarm) plot
# --------------------------------------------------
ggplot(df_long, aes(x = feature, y = value, color = diagnosis)) +
geom_beeswarm(size = 1.5, cex = 1) +  # controls point size, etc.
theme_minimal(base_size = 14) +
labs(
title = "Distribution of Mean Features by Diagnosis",
x = "Feature",
y = "Value"
) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),  # rotate x-axis labels
legend.position = "top"
)
# Load required libraries
# install.packages("ggplot2") # if not installed
# install.packages("zoo")    # if not installed
library(ggplot2)
library(zoo)
data("AirPassengers")
# Convert the AirPassengers time series into a data frame using as.yearmon for correct date conversion
df <- data.frame(
Month = as.Date(as.yearmon(time(AirPassengers))),  # Properly convert fractional years to dates
Passengers = as.numeric(AirPassengers)
)
# Plot: Bar + Line Chart
ggplot(df, aes(x = Month)) +
geom_col(aes(y = Passengers), fill = "salmon", width = 25) +  # Bar chart (width is in days)
geom_line(aes(y = Passengers), color = "blue", size = 1) +      # Line over bars
labs(
title = "Monthly International Airline Passengers (1949–1960)",
subtitle = "Data from the AirPassengers dataset",
x = "Month",
y = "Passengers"
) +
theme_minimal()
AirPassengers
AirPassengers.head()
AirPassengers.head
head(df_scaled)
head(AirPassengers)
AirPassengers.columns
AirPassengers.cols
colnames(AirPassengers)
# install.packages("ggplot2")  # if not already installed
library(ggplot2)
library(dplyr)
# Using our df from above
# Compare distribution of 'area_mean' for each diagnosis group
ggplot(df, aes(x = area_mean, fill = diagnosis)) +
geom_density(alpha = 0.6) +
theme_minimal() +
labs(
title = "Density Plot of Area Mean by Group",
x = "Area Mean",
y = "Density",
fill = "Group"
)
# --------------------------------------------------
# Install/load the required packages (uncomment if needed)
# --------------------------------------------------
# install.packages("dplyr")
# install.packages("tidyr")
# install.packages("ggplot2")
# install.packages("ggbeeswarm")
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggbeeswarm)
# --------------------------------------------------
# Create a synthetic dataset (Replace with your actual data)
# --------------------------------------------------
set.seed(42)
df <- data.frame(
radius_mean    = runif(100, min = 12, max = 16),
texture_mean   = runif(100, min = 15, max = 25),
perimeter_mean = runif(100, min = 70, max = 110),
area_mean      = runif(100, min = 350, max = 750),
concavity_mean = runif(100, min = 0.1, max = 0.5),
symmetry_mean  = runif(100, min = 0.15, max = 0.25),
diagnosis      = sample(c("Group A", "Group B"), 100, replace = TRUE)
)
# --------------------------------------------------
# Reshape data from wide to long
# --------------------------------------------------
df_long <- df %>%
pivot_longer(
cols = c(radius_mean, texture_mean, perimeter_mean,
area_mean, concavity_mean, symmetry_mean),
names_to = "feature",
values_to = "value"
)
# --------------------------------------------------
# Create the swarm (bee swarm) plot
# --------------------------------------------------
ggplot(df_long, aes(x = feature, y = value, color = diagnosis)) +
geom_beeswarm(size = 1.5, cex = 1) +
theme_minimal(base_size = 14) +
labs(
title = "Distribution of Mean Features by Group",
x = "Feature",
y = "Value"
) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "top"
)
# install.packages("ggplot2")  # if not already installed
library(ggplot2)
library(dplyr)
# Using our df from above
# Compare distribution of 'area_mean' for each diagnosis group
ggplot(df, aes(x = area_mean, fill = diagnosis)) +
geom_density(alpha = 0.6) +
theme_minimal() +
labs(
title = "Density Plot of Area Mean by Group",
x = "Area Mean",
y = "Density",
fill = "Group"
)
#| echo: false
library(tidyverse)
library(hrbrthemes)
library(viridis)
# create a dataset
data <- data.frame(
name=c( rep("A",500), rep("B",500), rep("B",500), rep("C",20), rep('D', 100)  ),
value=c( rnorm(500, 10, 5), rnorm(500, 13, 1), rnorm(500, 18, 1), rnorm(20, 25, 4), rnorm(100, 12, 1) )
)
# Plot
data %>%
ggplot( aes(x=name, y=value, fill=name)) +
geom_boxplot() +
scale_fill_viridis(discrete = TRUE, alpha=0.6) +
geom_jitter(color="black", size=0.4, alpha=0.9) +
theme_ipsum() +
theme(
legend.position="none",
plot.title = element_text(size=11)
) +
ggtitle("A boxplot with jitter") +
xlab("")
#| echo: false
library(tidyverse)
# install.packages("hrbrthemes")   # if needed
# install.packages("viridis")      # if needed
library(hrbrthemes)
library(viridis)
# Create a synthetic dataset
data2 <- data.frame(
name  = c( rep("A",500), rep("B",500), rep("B",500), rep("C",20), rep("D",100) ),
value = c( rnorm(500, 10, 5), rnorm(500, 13, 1), rnorm(500, 18, 1),
rnorm(20, 25, 4), rnorm(100, 12, 1) )
)
# Plot the box plot with jitter
data2 %>%
ggplot(aes(x = name, y = value, fill = name)) +
geom_boxplot() +
scale_fill_viridis(discrete = TRUE, alpha = 0.6) +
geom_jitter(color = "black", size = 0.4, alpha = 0.9) +
theme_ipsum() +
theme(
legend.position = "none",
plot.title = element_text(size = 11)
) +
ggtitle("Box Plot with Jitter") +
xlab("")
# Libraries
library(ggplot2)
library(dplyr)
library(forcats)
library(hrbrthemes)
library(viridis)
# Load dataset from github
data <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/10_OneNumSevCatSubgroupsSevObs.csv", header=T, sep=",") %>%
mutate(tip = round(tip/total_bill*100, 1))
# Grouped
data %>%
mutate(day = fct_reorder(day, tip)) %>%
mutate(day = factor(day, levels=c("Thur", "Fri", "Sat", "Sun"))) %>%
ggplot(aes(fill=sex, y=tip, x=day)) +
geom_violin(position="dodge", alpha=0.5, outlier.colour="transparent") +
scale_fill_viridis(discrete=T, name="") +
theme_ipsum()  +
xlab("") +
ylab("Tip (%)") +
ylim(0,40)
# Load required libraries
# install.packages("ggplot2") # if not installed
# install.packages("zoo")    # if not installed
library(ggplot2)
library(zoo)
data("AirPassengers")
# Convert the AirPassengers time series into a data frame using as.yearmon for correct date conversion
df <- data.frame(
Month = as.Date(as.yearmon(time(AirPassengers))),  # Properly convert fractional years to dates
Passengers = as.numeric(AirPassengers)
)
# Plot: Bar + Line Chart
ggplot(df, aes(x = Month)) +
geom_col(aes(y = Passengers), fill = "salmon", width = 25) +  # Bar chart (width is in days)
geom_line(aes(y = Passengers), color = "blue", size = 1) +      # Line over bars
labs(
title = "Monthly International Airline Passengers (1949–1960)",
subtitle = "Data from the AirPassengers dataset",
x = "Month",
y = "Passengers"
) +
theme_minimal()
# install.packages("corrplot")   # if not already installed
library(corrplot)
# Calculate correlation matrix using numeric columns from the synthetic dataset
num_cols <- c("radius_mean", "texture_mean", "perimeter_mean",
"area_mean", "concavity_mean", "symmetry_mean")
corr_matrix <- cor(df[, num_cols])
# --------------------------------------------------
# Install/load the required packages (uncomment if needed)
# --------------------------------------------------
# install.packages("dplyr")
# install.packages("tidyr")
# install.packages("ggplot2")
# install.packages("ggbeeswarm")
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggbeeswarm)
# --------------------------------------------------
# Create a synthetic dataset (Replace with your actual data)
# --------------------------------------------------
set.seed(42)
df <- data.frame(
radius_mean    = runif(100, min = 12, max = 16),
texture_mean   = runif(100, min = 15, max = 25),
perimeter_mean = runif(100, min = 70, max = 110),
area_mean      = runif(100, min = 350, max = 750),
concavity_mean = runif(100, min = 0.1, max = 0.5),
symmetry_mean  = runif(100, min = 0.15, max = 0.25),
diagnosis      = sample(c("Group A", "Group B"), 100, replace = TRUE)
)
# --------------------------------------------------
# Reshape data from wide to long
# --------------------------------------------------
df_long <- df %>%
pivot_longer(
cols = c(radius_mean, texture_mean, perimeter_mean,
area_mean, concavity_mean, symmetry_mean),
names_to = "feature",
values_to = "value"
)
# --------------------------------------------------
# Create the swarm (bee swarm) plot
# --------------------------------------------------
ggplot(df_long, aes(x = feature, y = value, color = diagnosis)) +
geom_beeswarm(size = 1.5, cex = 1) +
theme_minimal(base_size = 14) +
labs(
title = "Distribution of Mean Features by Group",
x = "Feature",
y = "Value"
) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "top"
)
# install.packages("corrplot")   # if not already installed
library(corrplot)
# Calculate correlation matrix using numeric columns from the synthetic dataset
num_cols <- c("radius_mean", "texture_mean", "perimeter_mean",
"area_mean", "concavity_mean", "symmetry_mean")
corr_matrix <- cor(df[, num_cols])
# Plot the correlation heatmap
corrplot(corr_matrix, method = "color", type = "upper",
addCoef.col = "black", tl.col = "black",
title = "Correlation Heatmap of Synthetic Features",
mar = c(0, 0, 2, 0))
# Reuse the synthetic dataset 'df'
ggplot(df, aes(x = radius_mean, y = area_mean, color = diagnosis)) +
geom_point(size = 2, alpha = 0.7) +
geom_smooth(method = "lm", se = FALSE) +
labs(
title = "Scatter Plot with Regression Line",
x = "Radius Mean",
y = "Area Mean"
) +
theme_minimal()
# Load required libraries
# install.packages("ggplot2") # if not installed
# install.packages("zoo")    # if not installed
library(ggplot2)
library(zoo)
data("AirPassengers")
# Convert the AirPassengers time series into a data frame using as.yearmon for correct date conversion
df_air <- data.frame(
Month = as.Date(as.yearmon(time(AirPassengers))),  # Properly convert fractional years to dates
Passengers = as.numeric(AirPassengers)
)
# Plot: Bar + Line Chart
ggplot(df_air, aes(x = Month)) +
geom_col(aes(y = Passengers), fill = "salmon", width = 25) +  # Bar chart (width is in days)
geom_line(aes(y = Passengers), color = "blue", size = 1) +      # Line over bars
labs(
title = "Monthly International Airline Passengers (1949–1960)",
subtitle = "Data from the AirPassengers dataset",
x = "Month",
y = "Passengers"
) +
theme_minimal()
colnames(df_air)
colnames(AirPassengers)
# Create synthetic data for a stacked bar chart
set.seed(123)
df_stack <- data.frame(
Region = sample(c("North", "South", "East", "West"), 200, replace = TRUE),
Preference = sample(c("Support", "Oppose", "Neutral"), 200, replace = TRUE)
)
# Generate the stacked bar chart
ggplot(df_stack, aes(x = Region, fill = Preference)) +
geom_bar(position = "stack") +
labs(
title = "Stacked Bar Chart of Preferences by Region",
x = "Region",
y = "Count"
) +
theme_minimal()
# Load required libraries for mapping
library(ggplot2)
library(maps)
install.packages(maps)
install.packages("mapproj")
# Load required libraries for mapping
library(ggplot2)
library(maps)
library(dplyr)
# Get the map data for US states
states_map <- map_data("state")
# Create synthetic social index data for each US state
set.seed(42)
state_data <- data.frame(
region = tolower(state.name),
social_index = runif(50, min = 0, max = 100)
)
# Merge the map data with the synthetic social index data
us_data <- left_join(states_map, state_data, by = "region")
# Plot the US States Choropleth Map
ggplot(us_data, aes(x = long, y = lat, group = group, fill = social_index)) +
geom_polygon(color = "white") +
coord_fixed(1.3) +
theme_minimal() +
labs(
title = "US States Social Index Choropleth",
fill = "Social Index"
)
# Get world map data
world_map <- map_data("world")
# Create synthetic data for global cities with social event counts
set.seed(123)
cities <- data.frame(
city = paste("City", 1:30),
long = runif(30, min = -180, max = 180),
lat  = runif(30, min = -90, max = 90),
event_count = sample(1:100, 30, replace = TRUE)
)
# Plot the world map with points for each city
ggplot() +
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "gray90", color = "white") +
geom_point(data = cities, aes(x = long, y = lat, size = event_count), color = "blue", alpha = 0.7) +
coord_fixed(1.3) +
theme_minimal() +
labs(
title = "Global Social Event Locations",
size = "Event Count"
)
# Get world map data
world_map <- map_data("world")
# Create synthetic data for global cities with social event counts
set.seed(123)
cities <- data.frame(
city = paste("City", 1:30),
long = runif(30, min = -180, max = 180),
lat  = runif(30, min = -90, max = 90),
event_count = sample(1:100, 30, replace = TRUE)
)
# Plot the world map with points for each city
ggplot() +
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "gray90", color = "white") +
geom_point(data = cities, aes(x = long, y = lat, size = event_count), color = "blue", alpha = 0.7) +
coord_fixed(1.3) +
theme_minimal() +
labs(
title = "Global Social Event Locations(On Synthetic Data!)",
size = "Event Count"
)
# Load required libraries for mapping
library(ggplot2)
library(maps)
library(dplyr)
# Get the map data for US states
states_map <- map_data("state")
# Create synthetic social index data for each US state
set.seed(42)
state_data <- data.frame(
region = tolower(state.name),
social_index = runif(50, min = 0, max = 100)
)
# Merge the map data with the synthetic social index data
us_data <- left_join(states_map, state_data, by = "region")
# Plot the US States Choropleth Map
ggplot(us_data, aes(x = long, y = lat, group = group, fill = social_index)) +
geom_polygon(color = "white") +
coord_fixed(1.3) +
theme_minimal() +
labs(
title = "US States Social Index Choropleth",
fill = "Social Index"
)
# Get world map data
world_map <- map_data("world")
# Create synthetic data for global cities with social event counts
set.seed(123)
cities <- data.frame(
city = paste("City", 1:30),
long = runif(30, min = -180, max = 180),
lat  = runif(30, min = -90, max = 90),
event_count = sample(1:100, 30, replace = TRUE)
)
# Plot the world map with points for each city
ggplot() +
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "gray90", color = "white") +
geom_point(data = cities, aes(x = long, y = lat, size = event_count), color = "blue", alpha = 0.7) +
coord_fixed(1.3) +
theme_minimal() +
labs(
title = "Global Social Event Locations(On Synthetic Data!)",
size = "Event Count"
)
setwd("Users/shyam/Documents/GESIS/Tutorials/Visualization-with-R")
setwd("Users/shyam/Documents/GESIS/Tutorials/Visualization-with-R/")
getwd()
setwd("/Users/shyam/Documents/GESIS/Tutorials/Visualization-with-R/")
setwd("/Users/shyam/Documents/GESIS/Tutorials/")
setwd("/Users/shyam/Documents/GESIS/Tutorials/Visualization-with-R/")
setwd("/Users/shyam/Documents/GESIS/Tutorials/Visualization with R/")
Rscript install.R
Rscript install.R
Rscripts
Rscript
